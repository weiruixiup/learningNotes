### 面向对象 （三要素）

1. 继承：子类继承父类

2. 封装：数据的权限和保密。

   - public：完全开发
   - private：对自己开发
   - protected：对自己和子类开发

   js目前没有这三种变量的修饰，Java，c#是有的，typescript也有的，默认是public。

3. 多态：同一接口，不同实现。

### SOLID五大设计原则

1. S - 单一职责原则：每个程序模块只负责一件事
2. O - 开发封闭原则：对扩展开放，对修改封闭
3. L - 李氏置换原则：所有父类出现的地方，子类也能出现
4. I - 独立接口原则：和单一职责原则类似，但是只用在接口
5. D - 依赖导致原则：依赖抽象和接口，不依赖具体实现

S,O的原则是比较多的。



### new的原理以及new方式创建对象和字面量创建的区别

new的调用过程中会发生四件事：

1. 新生成一个对象
2. 链接到原型
3. 绑定this
4. 返回新对象

### 工厂模式

理解：比如去KFC买一个汉堡，KFC会把汉堡做好（封装），你只需要取餐。构造函数和创建者分离，符合开放封闭原则。

```js
// 工厂创建了方法
class Product {
    constructor(name) {
        this.name = name
    }

    init() {
        console.log('init')
    }

    fn() {
        console.log('fn')
    }
}
// 这个暴露出去，生成实例
class Creator {
    create(name) {
        return new Product(name) // 核心  return new ...
    }
}

let creator = new Creator()
let person = creator.create('p1') 
person.init() // init
person.fn() // fn
```



### 单例模式

理解：系统中被唯一使用；一个类只能有一个实例。符合单一职责原则，只实例化一个对象。

```js
class SingleObject {
    login() {
        console.log('login')
    }
}

// 闭包 立即执行函数
// getInstance是SingleObject扩展的静态方法---private（注意这种写法）不论SingleObject被new多少次，都只有一个getInstance方法
SingleObject.getInstance = (function () {
    let instance
     return function () {
         if (!instance) instance = new SingleObject()
         return instance
     }
})()

let obj1 = SingleObject.getInstance()
obj1.login() //login

let obj2 = SingleObject.getInstance()
obj2.login() //login

console.log(obj1 === obj2); // true 

// 登录框就是单例模式的好例子
class LoginForm {
    constructor() {
        this.state = 'hide'
    }

    hide() {
        if (this.state = 'hide') {
            console.log('已经隐藏了')
            return
        }
        this.state = 'show'
        console.log('登录框隐藏成功')
    }

    show() {
        if (this.state = 'show') {
            console.log('已经显示了')
            return
        }
        this.state = 'hide'
        console.log('登录框显示成功')
    }
}

LoginForm.getInstance = (function () {
    let instance
    return function(){
		if (!instance) instance = new LoginForm()
    	return instance
    }
})()

let login1 = LoginForm.getInstance()
login1.show()  // 登录框已经隐藏
let login2 = LoginForm.getInstance()
login2.show() // 已经显示了
```



### 适配器模式

理解：旧接口格式和使用者不兼容；中间加一个适配转换接口。旧接口和使用者分离，符合开放封闭原则。

```js
// 被适配者
class Adaptee {
    // 具体请求
    specificRequest() {
        return '泰国标准插头'
    }
}

// 转换器
class Target {
    constructor() {
        this.adaptee = new Adaptee()
    }
    request(){
        let info = this.adaptee.specificRequest()
        return `${info} - 转换器 - 中国标准插头`
    }
}

let target = new Target()
let res = target.request()
console.log(res) // 泰国标准插头 - 转换器 - 中国标准插头
// vue中computed就是适配器模式
```



### 装饰器模式

理解：对对象添加新的功能；不改变其原有的结构功能。将现有对象和装饰器分离，两者独立存在。符合开放封闭原则。

```js
class Circle {
    draw() {
        console.log('画一个圆形')
    }
}

class Decorator {
    constructor(circle) {
        this.circle = circle
    }

    draw() {
        this.circle.draw()
        this.setRedBorder(circle)
    }

    setRedBorder(circle) {
        console.log('设置红色边框')
    }
}

let circle = new Circle()
circle.draw() // 画一个圆形
console.log(circle);
let dec = new Decorator(circle) // // 把new Circle 实例传入 new Decorator 并且赋值成 new Decorator 中的 circle 属性 这个属性拥有 Circle 中的 draw() 
console.log(dec);
dec.draw()
// 画一个圆形
// 设置红色边框
```

```js
ES7 装饰器
// npm install --save-dev babel-cli babel-preset-env
// npm install babel-plugin-transform-decorators-legacy --save-dev
//
// {
//     "presets": ["env"],
//     "plugins": ["transform-decorators-legacy"]
// }
类的装饰
    @testDemo
	class Demo {

    }

    function testDemo(target) {
        // console.log(target);
        target.isDec = true
    }

    console.log(Demo.isDec) // true

可以加参数
  function testDec(isDec) {
      // 装饰器必须返回一个函数
       return function (target) {
           target.isDec =isDec
       }
    }

    @testDec(false)
    class Demo {

    }

    console.log(Demo.isDec) // false

实现mixins
function mixins(...arg) {
        return function (target) {
            Object.assign(target.prototype, ...arg)
        }
    }

    const Foo = {
        foo() {
            console.log('foo')
        }
    }

    @mixins(Foo)
    class MyClass {

    }

    const myClass = new MyClass()
    console.log(myClass.foo) //  foo
```

